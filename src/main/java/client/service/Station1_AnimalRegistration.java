package client.service;

import client.interfaces.AnimalRegistrationSystem;
import grpc.*;
import server.controller.grpc.Animal_ToGrpc_AnimalData;
import shared.model.exceptions.AnimalNotFoundException;
import io.grpc.ManagedChannel;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import server.controller.grpc.GrpcAnimalData_To_Animal;
import server.controller.grpc.GrpcFactory;
import shared.model.entities.Animal;
import shared.model.exceptions.UpdateFailedException;

import java.math.BigDecimal;
import java.util.Collections;
import java.util.List;

public class Station1_AnimalRegistration extends Client implements AnimalRegistrationSystem
{
  public Station1_AnimalRegistration(String host, int port) {
    super(host, port);
  }


  @Override public Animal registerNewAnimal(BigDecimal weightInKilogram) throws InterruptedException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      SlaughterHouseServiceGrpc.SlaughterHouseServiceBlockingStub stub = SlaughterHouseServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of Animal (AnimalData)
      AnimalData data = GrpcFactory.buildGrpcAnimal(weightInKilogram);

      // Prompt gRPC to register the Animal:
      AnimalData createdAnimal = stub.registerAnimal(data);

      // Convert, and return, the AnimalData that was added to the DB into an application compatible format:
      return GrpcAnimalData_To_Animal.convertToAnimal(createdAnimal);

    } catch (StatusRuntimeException e) {
      // TODO: Implement proper exception handling.
      e.printStackTrace();
      return null;
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override public Animal readAnimal(long animalId) {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      SlaughterHouseServiceGrpc.SlaughterHouseServiceBlockingStub stub = SlaughterHouseServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of AnimalId (AnimalData)
      AnimalId id = GrpcFactory.buildGrpcAnimalId(animalId);

      // Prompt gRPC to read the Animal:
      AnimalData foundAnimal = stub.readAnimal(id);

      if(foundAnimal == null || foundAnimal.getAnimalId() == -1)
        throw new AnimalNotFoundException("No animal found with id '" + animalId);

      // Convert, and return, the AnimalData that was read from the DB into an application compatible format:
      return GrpcAnimalData_To_Animal.convertToAnimal(foundAnimal);

    } catch (StatusRuntimeException e) {
      throw new AnimalNotFoundException("No animal found with id '" + animalId);
    }
    finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override public void updateAnimal(Animal data) {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      SlaughterHouseServiceGrpc.SlaughterHouseServiceBlockingStub stub = SlaughterHouseServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of AnimalData
      AnimalData animal = Animal_ToGrpc_AnimalData.ConvertToAnimalData(data);

      // Prompt gRPC to update the Animal:
      EmptyMessage updated = stub.updateAnimal(animal);

      if(updated == null && data != null)
        throw new UpdateFailedException("Failed to update Animal with id '" + data.getId());

    } catch (StatusRuntimeException e) {
      throw new AnimalNotFoundException("No animal found with id '" + data.getId());
    }
    finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override public int removeAnimal(Animal data) {
    //TODO MISSING IMPLEMENTATION
    return 0;
  }


  @Override public List<Animal> getAllAnimals() {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      SlaughterHouseServiceGrpc.SlaughterHouseServiceBlockingStub stub = SlaughterHouseServiceGrpc.newBlockingStub(channel);

      // Prompt gRPC to retrieve the Animals from Database:
      AnimalsData animals = stub.getAllAnimals(GrpcFactory.buildGrpcEmptyMessage());

      // Convert, and return, the AnimalData that was added to the DB into an application compatible format:
      return GrpcAnimalData_To_Animal.convertToAnimalList(animals);

    } catch (StatusRuntimeException e) {
      // TODO: Implement proper exception handling.
      e.printStackTrace();
      return null;
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }
}
