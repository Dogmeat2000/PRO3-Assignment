package client.ui.Model.service;

import client.interfaces.TrayRegistrationSystem;
import client.ui.Model.adapters.gRPC_to_java.GrpcTrayData_To_TrayDto;
import client.ui.Model.adapters.java_to_gRPC.AnimalPartDto_ToGrpc_AnimalPartData;
import client.ui.Model.adapters.java_to_gRPC.ProductDto_ToGrpc_ProductData;
import client.ui.Model.adapters.java_to_gRPC.TrayDto_ToGrpc_TrayData;
import grpc.*;
import io.grpc.ManagedChannel;
import io.grpc.StatusRuntimeException;
import jakarta.transaction.Transactional;
import client.ui.Model.adapters.GrpcFactory;
import server.controller.grpc.adapters.grpc_to_java.GrpcTrayData_To_Tray;
import server.controller.grpc.adapters.java_to_gRPC.AnimalPart_ToGrpc_AnimalPartData;
import server.model.persistence.entities.AnimalPart;
import server.model.persistence.entities.Product;
import server.model.persistence.entities.Tray;
import shared.model.adapters.java_to_gRPC.LongId_ToGrpc_Id;
import server.controller.grpc.adapters.java_to_gRPC.Product_ToGrpc_ProductData;
import server.controller.grpc.adapters.java_to_gRPC.Tray_ToGrpc_TrayData;
import shared.model.dto.TrayDto;
import shared.model.exceptions.persistance.CreateFailedException;
import shared.model.exceptions.persistance.DeleteFailedException;
import shared.model.exceptions.persistance.NotFoundException;
import shared.model.exceptions.persistance.UpdateFailedException;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import static io.grpc.Status.NOT_FOUND;
import static io.grpc.Status.INTERNAL;

public class TrayRegistrationSystemImpl extends Client implements TrayRegistrationSystem
{
  private final GrpcTrayData_To_TrayDto grpcTrayDataConverter = new GrpcTrayData_To_TrayDto();
  private final TrayDto_ToGrpc_TrayData trayConverter = new TrayDto_ToGrpc_TrayData();
  private final AnimalPartDto_ToGrpc_AnimalPartData animalPartConverter = new AnimalPartDto_ToGrpc_AnimalPartData();
  private final ProductDto_ToGrpc_ProductData productConverter = new ProductDto_ToGrpc_ProductData();

  public TrayRegistrationSystemImpl(String host, int port) {
    super(host, port);
  }

  @Transactional
  @Override
  public TrayDto registerNewTray(BigDecimal maxWeight_kilogram) throws CreateFailedException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);
      //System.out.println("\n\nTray CUR-WEIGHT:  "+ currentWeight_kilogram);


      // Create a gRPC compatible version of Tray (TrayData)
      TrayData data = GrpcFactory.buildGrpcTrayData(1L, maxWeight_kilogram, BigDecimal.ZERO, new ArrayList<>(), new ArrayList<>(), null);

      //System.out.println("\n\nTrayData CUR-WEIGHT:  "+ data.getWeightKilogram());

      // Prompt gRPC to register the Tray:
      TrayData createdTray = trayStub.registerTray(data);

      /*System.out.println("\n\nCreated TrayData CUR-WEIGHT:  "+ createdTray.getWeightKilogram());
      System.out.println("Created TrayData AnimalPartList:  "+ createdTray.getAnimalPartListList());

      System.out.println("\n\nConverted Tray CUR-WEIGHT: " + grpcTrayDataConverter.convertToTray(createdTray,maxNestingDepth));*/

      // Convert, and return, the Tray that was added to the DB into an application compatible format:
      return grpcTrayDataConverter.convertToTrayDto(createdTray);

    } catch (StatusRuntimeException e) {
      e.printStackTrace(); // TODO: DELETE LINE
      throw new CreateFailedException("Failed to register Tray with maxWeight '" + maxWeight_kilogram + "kg'. (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public TrayDto readTray(long trayId) throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);
      /*AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);
      ProductServiceGrpc.ProductServiceBlockingStub productStub = ProductServiceGrpc.newBlockingStub(channel);*/

      // Create a gRPC compatible version of trayId (TrayId)
      TrayId id = LongId_ToGrpc_Id.convertToTrayId(trayId);

      // Prompt gRPC to read the Tray:
      TrayData foundTrayData = trayStub.readTray(id);

      // Convert the TrayData that was read from the DB into an application compatible format:
      return grpcTrayDataConverter.convertToTrayDto(foundTrayData);

      // Populate Tray with the proper relationships, to have a proper Object Relational Model.
      // Object relations are lost during gRPC conversion (due to cyclic relations, i.e. both Tray and AnimalPart have relations to each other), so must be repopulated:
      // TODO: Instead of accepting significant dataloss, instead refactor adapters/converters and define a max-nesting depth, so that at least 2-3 levels of objects get transferred correctly.
      /*try {
        // Read all Products associated with this Tray:
        AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByTrayId(LongId_ToGrpc_Id.convertToTrayId(tray.getTrayId()));

        // Convert to java language, and attach to Tray Object:
        tray.clearAnimalPartContents();
        tray.addAllAnimalParts(GrpcAnimalPartData_To_AnimalPart.convertToAnimalPartList(animalPartsData));
      } catch (StatusRuntimeException e) {
        if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
          // No AnimalParts found assigned to this Tray:
          throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with Tray_id '" + tray.getTrayId() + "' (" + e.getMessage() + ")");
      }

      try {
        // Read all Products associated with this Tray:
        ProductData productData;
        tray.setProductList(new ArrayList<>());
        for (TrayToProductTransfer transfer : tray.getTransferList()){
          productData = productStub.readProduct(LongId_ToGrpc_Id.convertToProductId(transfer.getProduct().getProductId()));

          // Convert to java language, and attach to Tray Object:
          tray.getProductList().add(GrpcProductData_To_Product.convertToProduct(productData, maxNestingDepth));
        }

      } catch (StatusRuntimeException e) {
        if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
          throw new RuntimeException("Critical Error encountered. Failed to Query for all Products associated with Tray_id '" + tray.getTrayId() + "' (" + e.getMessage() + ")");
      }*/

      // Return:
      //return tray;

    } catch (StatusRuntimeException e) {
      throw new NotFoundException("No Tray found with id '" + trayId + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Transactional
  @Override
  public void updateTray(TrayDto data) throws UpdateFailedException, NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of Tray (Convert Tray to TrayData)
      TrayData tray = trayConverter.convertToTrayData(data);

      // Prompt gRPC to update the Tray:
      EmptyMessage updated = trayStub.updateTray(tray);

      if(updated == null && data != null)
        throw new UpdateFailedException("Failed to update Tray with id '" + data.getTrayId() + "'");

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No Tray found with id '" + data.getTrayId() + "'");

      if(e.getStatus().equals(INTERNAL))
        throw new UpdateFailedException("Critical Error encountered. Failed to Update Tray with id '" + data.getTrayId() + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Transactional
  @Override
  public boolean removeTray(long trayId) throws DeleteFailedException, NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);
      ProductServiceGrpc.ProductServiceBlockingStub productStub = ProductServiceGrpc.newBlockingStub(channel);

      // Attempt to find a Tray with the given trayId:
      TrayDto tray = readTray(trayId);

      // Create a gRPC compatible version of Tray (Convert Tray to TrayData)
      TrayData trayData = trayConverter.convertToTrayData(tray);

      // Prompt gRPC to delete the Tray:
      EmptyMessage deleted = trayStub.removeTray(trayData);

      if(deleted == null && trayData != null)
        throw new DeleteFailedException("Failed to delete Tray with id '" + trayId + "'");

      // Check if there are any remaining AnimalParts associated with this Tray, if so delete these too:
      // TODO: Shouldn't be needed with JPA
      /*if(!tray.getAnimalPartIdList().isEmpty()) {
        // Prompt gRPC to delete the AnimalPart:
        for (AnimalPart animalPart : tray.getAnimalPartList()) {
          deleted = animalPartStub.removeAnimalPart(animalPartConverter.convertToAnimalPartData(animalPart, maxNestingDepth));

          if(deleted == null && animalPart != null)
            throw new DeleteFailedException("Failed to delete AnimalPart with id '" + animalPart.getPartId() + "' associated with Tray_id '" + trayId + "'");
        }
      }*/

      // Check if there are any remaining Products associated with this Tray, if so delete these too:
      // TODO: Shouldn't be needed with JPA
      /*
      if(!tray.getTransferList().isEmpty()) {
        // Prompt gRPC to delete the Product:
        for (Product product : tray.getProductList()) {
          deleted = productStub.removeProduct(productConverter.convertToProductData(product, maxNestingDepth));

          if(deleted == null && product != null)
            throw new DeleteFailedException("Failed to delete Product with id '" + product.getProductId() + "' associated with Tray_id '" + trayId + "'");
        }
      }*/

      return true;
    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No Tray found with id '" + trayId + "'");
      else
        throw new DeleteFailedException("Critical Error encountered. Failed to delete Tray with id '" + trayId + "' (" + e.getMessage() + ")");
    }
    finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public List<TrayDto> getAllTrays() throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);
      /*AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);
      ProductServiceGrpc.ProductServiceBlockingStub productStub = ProductServiceGrpc.newBlockingStub(channel);*/

      // Prompt gRPC to retrieve the Trays from the Database:
      TraysData traysData = trayStub.getAllTrays(GrpcFactory.buildGrpcEmptyMessage());

      // Convert received data to java language:
      return grpcTrayDataConverter.convertToTrayDtoList(traysData);

      // Populate each Tray with the proper relationships, to have a proper Object Relational Model.
      // Object relations are lost during gRPC conversion (due to cyclic relations, i.e. both Tray and AnimalPart have relations to each other), so must be repopulated:
      // TODO: Instead of accepting significant dataloss, instead refactor adapters/converters and define a max-nesting depth, so that at least 2-3 levels of objects get transferred correctly.
      /*for (Tray tray : trays) {
        try {
          // Read all AnimalParts associated with this Tray:
          AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByTrayId(LongId_ToGrpc_Id.convertToTrayId(tray.getTrayId()));

          // Convert to java language, and attach to Tray Object:
          tray.clearAnimalPartContents();
          tray.addAllAnimalParts(GrpcAnimalPartData_To_AnimalPart.convertToAnimalPartList(animalPartsData));
        } catch (StatusRuntimeException e) {
          if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
            // No AnimalParts found assigned to this Tray:
            throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with Tray_id '" + tray.getTrayId() + "' (" + e.getMessage() + ")");
        }

        try {
          // Read all Products associated with this Tray:
          ProductData productData;
          tray.setProductList(new ArrayList<>());
          for (TrayToProductTransfer transfer : tray.getTransferList()){
            productData = productStub.readProduct(LongId_ToGrpc_Id.convertToProductId(transfer.getProduct().getProductId()));

            // Convert to java language, and attach to Tray Object:
            tray.getProductList().add(GrpcProductData_To_Product.convertToProduct(productData, maxNestingDepth));
          }

        } catch (StatusRuntimeException e) {
          if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
            // No Products found assigned to this Tray:
            throw new RuntimeException("Critical Error encountered. Failed to Query for all Products associated with Tray_id '" + tray.getTrayId() + "' (" + e.getMessage() + ")");
        }
      }*/

      // Return data
      //return trays;

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No Trays found in database");
      else
        throw new RuntimeException("Critical Error encountered. Failed to Query all Trays from the Database (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }
}
