package client.ui.Model.service;

import client.interfaces.AnimalRegistrationSystem;
import grpc.*;
import org.springframework.transaction.annotation.Transactional;
import server.controller.grpc.grpc_to_java.GrpcAnimalPartData_To_AnimalPart;
import server.controller.grpc.java_to_gRPC.AnimalPart_ToGrpc_AnimalPartData;
import server.controller.grpc.java_to_gRPC.Animal_ToGrpc_AnimalData;
import server.controller.grpc.java_to_gRPC.LongId_ToGrpc_Id;
import shared.model.entities.AnimalPart;
import shared.model.exceptions.NotFoundException;
import io.grpc.ManagedChannel;
import io.grpc.StatusRuntimeException;
import server.controller.grpc.grpc_to_java.GrpcAnimalData_To_Animal;
import server.controller.grpc.GrpcFactory;
import shared.model.entities.Animal;
import shared.model.exceptions.CreateFailedException;
import shared.model.exceptions.DeleteFailedException;
import shared.model.exceptions.UpdateFailedException;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import static io.grpc.Status.INTERNAL;
import static io.grpc.Status.NOT_FOUND;

public class AnimalRegistrationSystemImpl extends Client implements AnimalRegistrationSystem
{
  public AnimalRegistrationSystemImpl(String host, int port) {
    super(host, port);
  }


  @Transactional
  @Override public Animal registerNewAnimal(BigDecimal weightInKilogram) throws CreateFailedException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalServiceGrpc.AnimalServiceBlockingStub stub = AnimalServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of Animal (AnimalData)
      AnimalData data = GrpcFactory.buildGrpcAnimal(weightInKilogram, new ArrayList<>());

      // Prompt gRPC to register the Animal:
      AnimalData createdAnimal = stub.registerAnimal(data);

      // Convert, and return, the AnimalData that was added to the DB into an application compatible format:
      return GrpcAnimalData_To_Animal.convertToAnimal(createdAnimal);

    } catch (StatusRuntimeException e) {
      throw new CreateFailedException("Failed to register animal with weight '" + weightInKilogram + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Transactional
  @Override public Animal readAnimal(long animalId) throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalServiceGrpc.AnimalServiceBlockingStub animalStub = AnimalServiceGrpc.newBlockingStub(channel);
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of AnimalId (AnimalData)
      AnimalId id = LongId_ToGrpc_Id.convertToAnimalId(animalId);

      // Prompt gRPC to read the Animal:
      AnimalData foundAnimal = animalStub.readAnimal(id);

      // Convert the AnimalData that was read from the DB into an application compatible format:
      Animal animal = GrpcAnimalData_To_Animal.convertToAnimal(foundAnimal);

      // Populate Animal with the proper relationships, to have a proper Object Relational Model.
      // Object relations are lost during gRPC conversion (due to cyclic relations, i.e. both Animal and AnimalPart have relations to each other), so must be repopulated:
      try {
        // Read all animalParts associated with this Animal:
        AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByAnimalId(LongId_ToGrpc_Id.convertToAnimalId(animal.getId()));

        // Convert to java language, and attach to Animal Object:
        animal.setAnimalParts(GrpcAnimalPartData_To_AnimalPart.convertToAnimalPartList(animalPartsData));
      } catch (StatusRuntimeException e) {
        if(e.getStatus().getCode().equals(NOT_FOUND.getCode())) {
          // No AnimalParts found assigned to this Animal:
          animal.setAnimalParts(new ArrayList<>());
        }
        else
          throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with Animal_id '" + animal.getId() + "' (" + e.getMessage() + ")");
      }

      // Return:
      return GrpcAnimalData_To_Animal.convertToAnimal(foundAnimal);

    } catch (StatusRuntimeException e) {
      throw new NotFoundException("No animal found with id '" + animalId + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Transactional
  @Override public void updateAnimal(Animal data) throws UpdateFailedException, NotFoundException {
    // TODO: Not implemented yet.
    throw new UpdateFailedException("Method not implemented!");
    /*
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalServiceGrpc.AnimalServiceBlockingStub animalStub = AnimalServiceGrpc.newBlockingStub(channel);
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of Animal (Convert Animal to AnimalData)
      AnimalData animal = Animal_ToGrpc_AnimalData.convertToAnimalData(data);

      // Prompt gRPC to update the Animal:
      EmptyMessage updated = animalStub.updateAnimal(animal);

      if(updated == null && data != null)
        throw new UpdateFailedException("Failed to update Animal with id '" + data.getId() + "'");

      // Update all associated AnimalParts:
      List<AnimalPart> oldAnimalPartList... // TODO

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No animal found with id '" + data.getId() + "'");

      if(e.getStatus().equals(INTERNAL))
        throw new UpdateFailedException("Critical Error encountered. Failed to Update Animal with id '" + data.getId() + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }*/
  }


  @Transactional
  @Override public boolean removeAnimal(long animal_id) throws DeleteFailedException, NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalServiceGrpc.AnimalServiceBlockingStub animalStub = AnimalServiceGrpc.newBlockingStub(channel);
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Attempt to find an Animal with the given animal_id:
      Animal animal = readAnimal(animal_id);

      // Create a gRPC compatible version of animal (Convert Animal to AnimalData)
      AnimalData animalData = Animal_ToGrpc_AnimalData.convertToAnimalData(animal);

      // Prompt gRPC to delete the Animal:
      EmptyMessage deleted = animalStub.removeAnimal(animalData);

      if(deleted == null && animal != null)
        throw new DeleteFailedException("Failed to delete Animal with id '" + animal_id + "'");

      // Check if there are any remaining AnimalParts associated with this Animal, if so delete these too:
      if(!animal.getAnimalPartIdList().isEmpty()) {
        // Prompt gRPC to delete the AnimalPart:
        for (AnimalPart animalPart : animal.getPartList()) {
          deleted = animalPartStub.removeAnimalPart(AnimalPart_ToGrpc_AnimalPartData.convertToAnimalPartData(animalPart));

          if(deleted == null && animalPart != null)
            throw new DeleteFailedException("Failed to delete AnimalPart with id '" + animalPart.getPart_id() + "' associated with Animal_id '" + animal_id + "'");
        }
      }

      return true;
    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No animal found with id '" + animal_id + "'");
      else
        throw new DeleteFailedException("Critical Error encountered. Failed to deleted Animal with id '" + animal_id + "' (" + e.getMessage() + ")");
    }
    finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Transactional
  @Override public List<Animal> getAllAnimals() throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalServiceGrpc.AnimalServiceBlockingStub animalStub = AnimalServiceGrpc.newBlockingStub(channel);
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Prompt gRPC to retrieve all Animals from Database:
      AnimalsData animalsData = animalStub.getAllAnimals(GrpcFactory.buildGrpcEmptyMessage());

      // Convert received data to java language:
      List<Animal> animals = GrpcAnimalData_To_Animal.convertToAnimalList(animalsData);

      // Populate each Animal with the proper relationships, to have a proper Object Relational Model.
      // Object relations are lost during gRPC conversion (due to cyclic relations, i.e. both Animal and AnimalPart have relations to each other), so must be repopulated:
      for (Animal animal : animals) {
        try {
          // Read all animalParts associated with this Animal:
          AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByAnimalId(LongId_ToGrpc_Id.convertToAnimalId(animal.getId()));

          // Convert to java language, and attach to Animal Object:
          animal.setAnimalParts(GrpcAnimalPartData_To_AnimalPart.convertToAnimalPartList(animalPartsData));
        } catch (StatusRuntimeException e) {
          if(e.getStatus().getCode().equals(NOT_FOUND.getCode())) {
            // No AnimalParts found assigned to this Animal:
            animal.setAnimalParts(new ArrayList<>());
          }
          else
            throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with Animal_id '" + animal.getId() + "' (" + e.getMessage() + ")");
        }
      }

      // Return data
      return animals;

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No animals found in database");
      else
        throw new RuntimeException("Critical Error encountered. Failed to Query for all Animals from the Database (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }
}
