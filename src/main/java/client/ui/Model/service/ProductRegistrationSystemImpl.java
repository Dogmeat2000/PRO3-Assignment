package client.ui.Model.service;

import client.interfaces.ProductRegistrationSystem;
import grpc.*;
import io.grpc.ManagedChannel;
import io.grpc.StatusRuntimeException;
import server.controller.grpc.adapters.GrpcFactory;
import server.controller.grpc.adapters.grpc_to_java.GrpcAnimalPartData_To_AnimalPart;
import server.controller.grpc.adapters.grpc_to_java.GrpcProductData_To_Product;
import server.controller.grpc.adapters.grpc_to_java.GrpcTrayData_To_Tray;
import server.controller.grpc.adapters.java_to_gRPC.AnimalPart_ToGrpc_AnimalPartData;
import server.controller.grpc.adapters.java_to_gRPC.LongId_ToGrpc_Id;
import server.controller.grpc.adapters.java_to_gRPC.Product_ToGrpc_ProductData;
import server.controller.grpc.adapters.java_to_gRPC.Tray_ToGrpc_TrayData;
import shared.model.entities.AnimalPart;
import shared.model.entities.Product;
import shared.model.entities.Tray;
import shared.model.entities.TrayToProductTransfer;
import shared.model.exceptions.persistance.CreateFailedException;
import shared.model.exceptions.persistance.DeleteFailedException;
import shared.model.exceptions.persistance.NotFoundException;
import shared.model.exceptions.persistance.UpdateFailedException;

import java.util.ArrayList;
import java.util.List;

import static io.grpc.Status.INTERNAL;
import static io.grpc.Status.NOT_FOUND;

public class ProductRegistrationSystemImpl extends Client implements ProductRegistrationSystem
{
  public ProductRegistrationSystemImpl(String host, int port) {
    super(host, port);
  }


  @Override
  public Product registerNewProduct(List<AnimalPart> animalPartContentList, List<Tray> receivedPartsFromTrayList) throws CreateFailedException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      ProductServiceGrpc.ProductServiceBlockingStub productStub = ProductServiceGrpc.newBlockingStub(channel);
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of Product (ProductData), with an initially empty list of Tray relations
      List<Long> animalPartIdList = new ArrayList<>();
      for (AnimalPart animalPart : animalPartContentList)
        animalPartIdList.add(animalPart.getPart_id());

      List<Long> receivedPartIdList = new ArrayList<>();
      for(Tray receivedFromTray : receivedPartsFromTrayList)
        receivedPartIdList.add(receivedFromTray.getTrayId());

      ProductData data = GrpcFactory.buildGrpcProductData(animalPartIdList, receivedPartIdList);

      // Prompt gRPC to register the ProductData:
      ProductData createdProduct = productStub.registerProduct(data);

      // Convert the ProductData that was read from the DB into an application compatible format:
      Product product = GrpcProductData_To_Product.convertToProduct(createdProduct, 3);

      // Populate Product with the proper relationships, to have a proper Object Relational Model.
      // Object relations are lost during gRPC conversion (due to cyclic relations, i.e. both Product and AnimalPart have relations to each other), so must be repopulated:
      // TODO: Instead of accepting significant dataloss, instead refactor adapters/converters and define a max-nesting depth, so that at least 2-3 levels of objects get transferred correctly.
      try {
        // Read all animalParts associated with this Product:
        AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByProductId(LongId_ToGrpc_Id.convertToProductId(createdProduct.getProductId()));

        // Convert to java language, and attach to Product Object:
        product.setAnimalParts(GrpcAnimalPartData_To_AnimalPart.convertToAnimalPartList(animalPartsData));
      } catch (StatusRuntimeException e) {
        if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
          // No AnimalParts found assigned to this Animal:
          throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with Product_id '" + product.getProductId() + "' (" + e.getMessage() + ")");
      }

      try {
        // Read all Trays associated with this Product:
        TrayData trayData;
        product.setTraySuppliersList(new ArrayList<>());
        for (TrayToProductTransfer transfer : product.getTraySupplyJoinList()){
          trayData = trayStub.readTray(LongId_ToGrpc_Id.convertToTrayId(transfer.getTray().getTrayId()));

          // Convert to java language, and attach to Product Object:
          product.getTraySuppliersList().add(GrpcTrayData_To_Tray.convertToTray(trayData,3));
        }

      } catch (StatusRuntimeException e) {
        if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
          throw new RuntimeException("Critical Error encountered. Failed to Query for all Trays associated with Product_id '" + product.getProductId() + "' (" + e.getMessage() + ")");
      }

      // Return:
      return product;

    } catch (StatusRuntimeException e) {
      throw new CreateFailedException("Failed to register Product (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public Product readProduct(long productId) throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      ProductServiceGrpc.ProductServiceBlockingStub productStub = ProductServiceGrpc.newBlockingStub(channel);
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of productId (ProductId)
      ProductId id = LongId_ToGrpc_Id.convertToProductId(productId);

      // Prompt gRPC to read the PartType:
      ProductData foundProduct = productStub.readProduct(id);

      // Convert the TrayData that was read from the DB into an application compatible format:
      Product product = GrpcProductData_To_Product.convertToProduct(foundProduct, 3);

      // Populate Product with the proper relationships, to have a proper Object Relational Model.
      // Object relations are lost during gRPC conversion (due to cyclic relations, i.e. both Product and AnimalPart have relations to each other), so must be repopulated:
      // TODO: Instead of accepting significant dataloss, instead refactor adapters/converters and define a max-nesting depth, so that at least 2-3 levels of objects get transferred correctly.
      try {
        // Read all AnimalParts associated with this Product:
        AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByTrayId(LongId_ToGrpc_Id.convertToTrayId(product.getProductId()));

        // Convert to java language, and attach to Product Object:
        product.getContentList().clear();
        product.setAnimalParts(GrpcAnimalPartData_To_AnimalPart.convertToAnimalPartList(animalPartsData));
      } catch (StatusRuntimeException e) {
        if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
          // No AnimalParts found assigned to this Tray:
          throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with Product_id '" + product.getProductId() + "' (" + e.getMessage() + ")");
      }

      try {
        // Read all Trays associated with this Product:
        TrayData trayData;
        product.setTraySuppliersList(new ArrayList<>());
        for (TrayToProductTransfer transfer : product.getTraySupplyJoinList()){
          trayData = trayStub.readTray(LongId_ToGrpc_Id.convertToTrayId(transfer.getTray().getTrayId()));

          // Convert to java language, and attach to Product Object:
          product.getTraySuppliersList().add(GrpcTrayData_To_Tray.convertToTray(trayData,3));
        }

      } catch (StatusRuntimeException e) {
        if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
          throw new RuntimeException("Critical Error encountered. Failed to Query for all Products associated with Tray_id '" + product.getProductId() + "' (" + e.getMessage() + ")");
      }

      // Return:
      return product;

    } catch (StatusRuntimeException e) {
      throw new NotFoundException("No Product found with id '" + productId + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public void updateProduct(Product data) throws UpdateFailedException, NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      ProductServiceGrpc.ProductServiceBlockingStub productStub = ProductServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of Product (Convert Product to ProductData)
      ProductData product = Product_ToGrpc_ProductData.convertToProductData(data, 3);

      // Prompt gRPC to update the Product:
      EmptyMessage updated = productStub.updateProduct(product);

      if(updated == null && data != null)
        throw new UpdateFailedException("Failed to update Product with id '" + data.getProductId() + "'");

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No Product found with id '" + data.getProductId() + "'");

      if(e.getStatus().equals(INTERNAL))
        throw new UpdateFailedException("Critical Error encountered. Failed to Update Product with id '" + data.getProductId() + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public boolean removeProduct(long productId) throws DeleteFailedException, NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      ProductServiceGrpc.ProductServiceBlockingStub productStub = ProductServiceGrpc.newBlockingStub(channel);
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Attempt to find an PartType with the given typeId:
      Product product = readProduct(productId);

      // Create a gRPC compatible version of PartType (Convert PartType to PartTypeData)
      ProductData productData = Product_ToGrpc_ProductData.convertToProductData(product, 3);

      // Prompt gRPC to delete the PartType:
      EmptyMessage deleted = productStub.removeProduct(productData);

      if(deleted == null && productData != null)
        throw new DeleteFailedException("Failed to delete Product with id '" + productId + "'");

      // Check if there are any remaining AnimalParts associated with this Product, if so update these:
      if(!product.getAnimalPartIdList().isEmpty()) {
        // Prompt gRPC to update the AnimalPart:
        for (AnimalPart animalPart : product.getContentList()) {
          animalPart.setProduct(null);
          animalPartStub.updateAnimalPart(AnimalPart_ToGrpc_AnimalPartData.convertToAnimalPartData(animalPart));

          if(deleted == null)
            throw new UpdateFailedException("Failed to update AnimalPart with id '" + animalPart.getPart_id() + "' associated with Product_id '" + productId + "'");
        }
      }

      // Check if there are any remaining Trays associated with this Product, if so update these:
      if(!product.getTraySuppliersList().isEmpty()) {
        // Prompt gRPC to delete the Product:
        for (Tray tray : product.getTraySuppliersList()) {
          tray.getProductList().remove(product);
          trayStub.updateTray(Tray_ToGrpc_TrayData.convertToTrayData(tray,3));

          if(deleted == null)
            throw new UpdateFailedException("Failed to update Tray with id '" + product.getProductId() + "' associated with Tray_id '" + productId + "'");
        }
      }

      return true;
    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No Product found with id '" + productId + "'");
      else
        throw new DeleteFailedException("Critical Error encountered. Failed to delete Product with id '" + productId + "' (" + e.getMessage() + ")");
    }
    finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public List<Product> getAllProducts() throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      ProductServiceGrpc.ProductServiceBlockingStub productStub = ProductServiceGrpc.newBlockingStub(channel);
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Prompt gRPC to retrieve the AnimalParts from the Database:
      ProductsData productsData = productStub.getAllProducts(GrpcFactory.buildGrpcEmptyMessage());

      // Convert received data to java language:
      List<Product> products = GrpcProductData_To_Product.convertToProductList(productsData);

      // Populate each Product with the proper relationships, to have a proper Object Relational Model.
      // Object relations are lost during gRPC conversion (due to cyclic relations, i.e. both Product and AnimalPart have relations to each other), so must be repopulated:
      // TODO: Instead of accepting significant dataloss, instead refactor adapters/converters and define a max-nesting depth, so that at least 2-3 levels of objects get transferred correctly.
      for (Product product : products) {
        try {
          // Read all AnimalParts associated with this Product:
          AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByProductId(LongId_ToGrpc_Id.convertToProductId(product.getProductId()));

          // Convert to java language, and attach to Product Object:
          product.getContentList().clear();
          product.setAnimalParts(GrpcAnimalPartData_To_AnimalPart.convertToAnimalPartList(animalPartsData));
        } catch (StatusRuntimeException e) {
          if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
            // No AnimalParts found assigned to this Product:
            throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with Product_id '" + product.getProductId() + "' (" + e.getMessage() + ")");
        }

        try {
          // Read all Trays associated with this Product:
          TrayData trayData;
          product.setTraySuppliersList(new ArrayList<>());
          for (TrayToProductTransfer transfer : product.getTraySupplyJoinList()){
            trayData = trayStub.readTray(LongId_ToGrpc_Id.convertToTrayId(transfer.getTray().getTrayId()));

            // Convert to java language, and attach to Product Object:
            product.getTraySuppliersList().add(GrpcTrayData_To_Tray.convertToTray(trayData,3));
          }

        } catch (StatusRuntimeException e) {
          if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
            // No Products found assigned to this Tray:
            throw new RuntimeException("Critical Error encountered. Failed to Query for all Trays associated with Product_id '" + product.getProductId() + "' (" + e.getMessage() + ")");
        }
      }

      // Return data
      return products;

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No Products found in database");
      else
        throw new RuntimeException("Critical Error encountered. Failed to Query all Products from the Database (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }
}
