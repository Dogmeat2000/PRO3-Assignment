package client.ui.Model.service;

import client.interfaces.AnimalPartRegistrationSystem;
import client.ui.Model.adapters.gRPC_to_java.GrpcAnimalPartData_To_AnimalPartDto;
import client.ui.Model.adapters.java_to_gRPC.AnimalPartDto_ToGrpc_AnimalPartData;
import grpc.*;
import io.grpc.ManagedChannel;
import io.grpc.StatusRuntimeException;
import client.ui.Model.adapters.GrpcFactory;
import server.controller.grpc.adapters.grpc_to_java.*;
import server.controller.grpc.adapters.java_to_gRPC.AnimalPart_ToGrpc_AnimalPartData;
import server.model.persistence.entities.Animal;
import server.model.persistence.entities.AnimalPart;
import server.model.persistence.entities.PartType;
import server.model.persistence.entities.Tray;
import shared.model.adapters.java_to_gRPC.LongId_ToGrpc_Id;
import shared.model.dto.AnimalDto;
import shared.model.dto.AnimalPartDto;
import shared.model.dto.PartTypeDto;
import shared.model.dto.TrayDto;
import shared.model.exceptions.persistance.CreateFailedException;
import shared.model.exceptions.persistance.DeleteFailedException;
import shared.model.exceptions.persistance.NotFoundException;
import shared.model.exceptions.persistance.UpdateFailedException;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import static io.grpc.Status.INTERNAL;
import static io.grpc.Status.NOT_FOUND;

public class AnimalPartRegistrationSystemImpl extends Client implements AnimalPartRegistrationSystem
{
  private final GrpcAnimalPartData_To_AnimalPartDto grpcAnimalPartDataConverter = new GrpcAnimalPartData_To_AnimalPartDto();
  private final AnimalPartDto_ToGrpc_AnimalPartData animalPartConverter = new AnimalPartDto_ToGrpc_AnimalPartData();


  public AnimalPartRegistrationSystemImpl(String host, int port) {
    super(host, port);
  }


  @Override
  public AnimalPartDto registerNewAnimalPart(AnimalDto animal, PartTypeDto type, TrayDto tray, BigDecimal weightInKilogram) throws CreateFailedException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of AnimalPart (AnimalPartData)
      //System.out.println("[AnimalPartRegistrationSystemImpl] animalPartId=" + 1 + "animal=" + animal + ", partType=" + type + ", tray=" + tray + ", weightInKilogram=" + weightInKilogram + "\n");
      AnimalPartData data = GrpcFactory.buildGrpcAnimalPartData(1, animal, type, tray, weightInKilogram);
      //System.out.println("[AnimalPartRegistrationSystemImpl] Received this AnimalPart: " + data);

      // Prompt gRPC to register the AnimalPart:
      AnimalPartData createdAnimalPartData = animalPartStub.registerAnimalPart(data);
      //System.out.println("[AnimalPartRegistrationSystemImpl] Registered this AnimalPart: " + data);

      // Populate AnimalPart with the proper relationships, to have a proper Object Relational Model.
      // Object relations are lost during gRPC conversion (due to cyclic relations, i.e. AnimalPart and Animal have relations to each other), so must be repopulated:
      // TODO: Instead of accepting significant dataloss, instead refactor adapters/converters and define a max-nesting depth, so that at least 2-3 levels of objects get transferred correctly.
      //return readAnimalPart(createdAnimalPartData.getAnimalPartId().getAnimalPartId());
      //System.out.println("[AnimalPartRegistrationSystemImpl] Returning this AnimalPart: " + grpcAnimalPartDataConverter.convertToAnimalPart(createdAnimalPartData, maxNestingDepth));
      return grpcAnimalPartDataConverter.convertToAnimalPartDto(createdAnimalPartData);

    } catch (StatusRuntimeException e) {
      throw new CreateFailedException("Failed to register AnimalPart with weight '" + weightInKilogram + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public AnimalPartDto readAnimalPart(long animalPartId) throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);
      /*AnimalServiceGrpc.AnimalServiceBlockingStub animalStub = AnimalServiceGrpc.newBlockingStub(channel);
      PartTypeServiceGrpc.PartTypeServiceBlockingStub partTypeStub = PartTypeServiceGrpc.newBlockingStub(channel);
      ProductServiceGrpc.ProductServiceBlockingStub productStub = ProductServiceGrpc.newBlockingStub(channel);
      TrayServiceGrpc.TrayServiceBlockingStub trayStub = TrayServiceGrpc.newBlockingStub(channel);*/

      // Create a gRPC compatible version of AnimalPart (AnimalPartId):
      AnimalPartId id = LongId_ToGrpc_Id.convertToAnimalPartId(animalPartId);

      // Prompt gRPC to read the AnimalPart:
      AnimalPartData foundAnimalPart = animalPartStub.readAnimalPart(id);

      // Convert the AnimalData that was read from the DB into a java compatible format:
      return grpcAnimalPartDataConverter.convertToAnimalPartDto(foundAnimalPart);

      // Populate AnimalPart with the proper relationships, to have a proper Object Relational Model.
      // Object relations are lost during gRPC conversion (due to cyclic relations, i.e. both AnimalPart and Animal have relations to each other), so must be repopulated:
      // TODO: Instead of accepting significant dataloss, instead refactor adapters/converters and define a max-nesting depth, so that at least 2-3 levels of objects get transferred correctly.
      /*try {
        // Read the Animal associated with this AnimalPart:
        AnimalData animalData = animalStub.readAnimal(LongId_ToGrpc_Id.convertToAnimalId(foundAnimalPart.getAnimal().getAnimalId()));

        // Convert to java language, and attach to AnimalPart Object:
        animalPart.setAnimal(grpcAnimalDataConverter.convertToAnimalDto(animalData, maxNestingDepth));
      } catch (StatusRuntimeException e) {
        if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
          // No Animal found assigned to this AnimalPart:
          throw new RuntimeException("Critical Error encountered. Failed to Query the Animal associated with AnimalPart_id '" + animalPartId + "' (" + e.getMessage() + ")");
      }*/

      /*try {
        // Read the Tray associated with this AnimalPart:
        TrayData trayData = trayStub.readTray(LongId_ToGrpc_Id.convertToTrayId(foundAnimalPart.getTray().getTrayId()));

        // Convert to java language, and attach to AnimalPart Object:
        animalPart.setTray(GrpcTrayData_To_Tray.convertToTray(trayData,maxNestingDepth));
      } catch (StatusRuntimeException e) {
        if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
          // No Tray found assigned to this AnimalPart:
          throw new RuntimeException("Critical Error encountered. Failed to Query the Tray associated with AnimalPart_id '" + animalPartId + "' (" + e.getMessage() + ")");
      }*/

      /*try {
        // Read the PartType associated with this AnimalPart:
        PartTypeData partTypeData = partTypeStub.readPartType(LongId_ToGrpc_Id.convertToPartTypeId(foundAnimalPart.getPartType().getPartTypeId()));

        // Convert to java language, and attach to AnimalPart Object:
        animalPart.setType(GrpcPartTypeData_To_PartType.convertToPartType(partTypeData, maxNestingDepth));
      } catch (StatusRuntimeException e) {
        if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
          // No PartType found assigned to this AnimalPart:
          throw new RuntimeException("Critical Error encountered. Failed to Query the Tray associated with AnimalPart_id '" + animalPartId + "' (" + e.getMessage() + ")");
      }*/

      /*if(animalPart.getProduct() != null && animalPart.getProduct().getProductId() != 0)  {
        try {
          // Read the Product associated with this AnimalPart:
          ProductData productData = productStub.readProduct(LongId_ToGrpc_Id.convertToProductId(foundAnimalPart.getProduct().getProductId()));

          // Convert to java language, and attach to AnimalPart Object:
          animalPart.setProduct(GrpcProductData_To_Product.convertToProduct(productData, maxNestingDepth));
        } catch (StatusRuntimeException e) {
          if(!e.getStatus().getCode().equals(NOT_FOUND.getCode()))
            // No Product found assigned to this AnimalPart:
            throw new RuntimeException("Critical Error encountered. Failed to Query the Product associated with AnimalPart_id '" + animalPartId + "' (" + e.getMessage() + ")");
        }
      }*/

      // Return:
      //return animalPart;

    } catch (StatusRuntimeException e) {
      throw new NotFoundException("No animalPart found with id '" + animalPartId + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public List<AnimalPartDto> readAnimalPartsByAnimalId(long animalId) throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Prompt gRPC to retrieve the AnimalParts from Database:
      AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByAnimalId(LongId_ToGrpc_Id.convertToAnimalId(animalId));

      // Read each entity individually (should be using the cached version now), to get all the proper entity relations:
      return new ArrayList<>(grpcAnimalPartDataConverter.convertToAnimalPartDtoList(animalPartsData));
      /*for (AnimalPart animalPart : grpcAnimalPartDataConverter.convertToAnimalPartList(animalPartsData, maxNestingDepth))
        animalParts.add(readAnimalPart(animalPart.getPart_id()));*/

      //return animalParts;

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No AnimalParts associated with animal_id '" + animalId + "' found in database");
      else
        throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with animal_id '" + animalId + "' from the Database (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public List<AnimalPartDto> readAnimalPartsByPartTypeId(long partTypeId) throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Prompt gRPC to retrieve the AnimalParts from Database:
      AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByPartTypeId(LongId_ToGrpc_Id.convertToPartTypeId(partTypeId));

      // Read each entity individually (should be using the cached version now), to get all the proper entity relations:
      return new ArrayList<>(grpcAnimalPartDataConverter.convertToAnimalPartDtoList(animalPartsData));
      /*for (AnimalPart animalPart : grpcAnimalPartDataConverter.convertToAnimalPartList(animalPartsData, maxNestingDepth))
        animalParts.add(readAnimalPart(animalPart.getPart_id()));*/

      //return animalParts;

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No AnimalParts associated with partType_Id '" + partTypeId + "' found in database");
      else
        throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with partType_Id '" + partTypeId + "' from the Database (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public List<AnimalPartDto> readAnimalPartsByProductId(long productId) throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Prompt gRPC to retrieve the AnimalParts from Database:
      AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByProductId(LongId_ToGrpc_Id.convertToProductId(productId));

      // Read each entity individually (should be using the cached version now), to get all the proper entity relations:
      return new ArrayList<>(grpcAnimalPartDataConverter.convertToAnimalPartDtoList(animalPartsData));
      /*for (AnimalPart animalPart : grpcAnimalPartDataConverter.convertToAnimalPartList(animalPartsData, maxNestingDepth))
        animalParts.add(readAnimalPart(animalPart.getPart_id()));*/

      //return animalParts;

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No AnimalParts associated with product_Id '" + productId + "' found in database");
      else
        throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with product_Id '" + productId + "' from the Database (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public List<AnimalPartDto> readAnimalPartsByTrayId(long trayId) throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Prompt gRPC to retrieve the AnimalParts from Database:
      AnimalPartsData animalPartsData = animalPartStub.readAnimalPartsByTrayId(LongId_ToGrpc_Id.convertToTrayId(trayId));

      // Read each entity individually (should be using the cached version now), to get all the proper entity relations:
      return new ArrayList<>(grpcAnimalPartDataConverter.convertToAnimalPartDtoList(animalPartsData));
      /*for (AnimalPart animalPart : grpcAnimalPartDataConverter.convertToAnimalPartList(animalPartsData, maxNestingDepth))
        animalParts.add(readAnimalPart(animalPart.getPart_id()));*/

      //return animalParts;

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No AnimalParts associated with tray_Id '" + trayId + "' found in database");
      else
        throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts associated with tray_Id '" + trayId + "' from the Database (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public void updateAnimalPart(AnimalPartDto data) throws UpdateFailedException, NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Create a gRPC compatible version of AnimalPart (Convert AnimalPart to UpdatedAnimalPartData)
      AnimalPartData updateData = animalPartConverter.convertToAnimalPartData(data);

      // Prompt gRPC to update the Animal:
      EmptyMessage updated = animalPartStub.updateAnimalPart(updateData);

      if(updated == null && updateData != null)
        throw new UpdateFailedException("Failed to update AnimalPart with id '" + data.getPartId() + "'");

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No AnimalPart found with id '" + data.getPartId() + "'");

      if(e.getStatus().equals(INTERNAL))
        throw new UpdateFailedException("Critical Error encountered. Failed to Update AnimalPart with id '" + data.getPartId() + "' (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public boolean removeAnimalPart(AnimalPartDto data) throws DeleteFailedException, NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Attempt to find an Animal with the given animal_id:
      AnimalPartDto animalPart = readAnimalPart(data.getPartId());

      // Create a gRPC compatible version of AnimalPart (Convert AnimalPart to AnimalPartData)
      AnimalPartData animalPartData = animalPartConverter.convertToAnimalPartData(animalPart);

      // Prompt gRPC to delete the AnimalPart:
      //System.out.println("\n\nTimestamp format is: " + animalPartData.get().getArrivalDate());
      EmptyMessage deleted = animalPartStub.removeAnimalPart(animalPartData);

      if(deleted == null && animalPart != null)
        throw new DeleteFailedException("Failed to delete AnimalPart with id '" + data.getPartId() + "'");

      return true;
    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No AnimalPart found with id '" + data.getPartId() + "'");
      else {
        e.printStackTrace(); // TODO: DELETE
        throw new DeleteFailedException("Critical Error encountered. Failed to delete AnimalPart with id '" + data.getPartId() + "' (" + e.getMessage() + ")");
      }
    }
    finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }


  @Override
  public List<AnimalPartDto> getAllAnimalParts() throws NotFoundException {
    // Create a managed channel to connect to the gRPC server:
    ManagedChannel channel = channel();

    try {
      // Create a BlockingStub, which is auto-generated by the proto file, and in essence is the client connection manager!
      AnimalPartServiceGrpc.AnimalPartServiceBlockingStub animalPartStub = AnimalPartServiceGrpc.newBlockingStub(channel);

      // Prompt gRPC to retrieve the AnimalParts from Database:
      AnimalPartsData animalPartsData = animalPartStub.getAnimalParts(GrpcFactory.buildGrpcEmptyMessage());

      // Read each entity individually (should be using the cached version now), to get all the proper entity relations:
      return new ArrayList<>(grpcAnimalPartDataConverter.convertToAnimalPartDtoList(animalPartsData));
      /*for (AnimalPart animalPart : grpcAnimalPartDataConverter.convertToAnimalPartList(animalPartsData, maxNestingDepth))
        animalParts.add(readAnimalPart(animalPart.getPart_id()));*/

      //return animalParts;

    } catch (StatusRuntimeException e) {
      if(e.getStatus().getCode().equals(NOT_FOUND.getCode()))
        throw new NotFoundException("No AnimalParts found in database");
      else
        throw new RuntimeException("Critical Error encountered. Failed to Query for all AnimalParts from the Database (" + e.getMessage() + ")");
    } finally {
      // Always shut down the channel after use, to reduce server congestion and 'application hanging'.
      channel.shutdown();
    }
  }
}
